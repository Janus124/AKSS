Kein Programm ist vollkommen sicher. Obwohl das Konzept von TEEs darauf abzielt, Programme besser zu schützen, bestehen dennoch Angriffsmöglichkeiten. Jo Van Bulck et al (Link) haben ihre untersuchten Sicherheitslücken in zwei Kategorien eingeteilt: die ABI-Ebene und die API-Ebene.

Mit ABI-Ebene sind damit die (1) potentiellen Schwachstellen beim Erstellen und Verlassen der Enklave gemeint. Dazu gehören Zustände und Flags der Register, die während der Enklaven-Erstellung gesetzt sein können und das Veralten des Programmes beeinflussen, sowie die Bereinigung des Stacks. 
Außerdem müssen beim Verlassen sämtliche Daten der Register, der CPU und sonstige Medien gelöscht werden, um Rückschlüsse auf die innerhalb der Enklave verarbeiteten Daten zu verhindern.

Die API-Ebene beschreibt das funktionale Interface der Enklave, insbesondere, wie Daten zwischen der sicheren und unsicheren Welt übertragen werden. Hierzu gehört die Überprüfung, dass (2) Zeiger innerhalb des erwarteten, freigegebenen Speicherbereichs liegen. Die (3) Länge der Strings muss überprüft werden und es muss sichergestellt werden, dass die Zeichenkette nullterminert. Wird das nicht gemacht, sind z.B. Seitenkanalangriffe möglich, die Informationen über den internen Speicher der Enklave preisgeben können. 

Ein weiterer wichtiger Punkt ist die Gewährleistung, dass (4) der gesamte Speicherbereich, auf den ein Zeiger verweist, außerhalb der Enklave liegt, wenn ein Buffer oder ein größerer Datentyp übertragen wird. Wird dies nicht berücksichtigt, ist es möglich, dass der privilegierte Enklave Prozess den eigenen oder andere privilegierte Speicherbereiche überschreibt. (5) Integer-Überläufe bei der Berechnung von Adressen müssen berücksichtigt werden. Auch dieser Angriff zielt darauf ab, die Grenzen des privilegierten Speicherbereiches der TEE zu durchbrechen. 

Eine weitere potenzielle Angriffsmöglichkeit ist der (6) double fetch. Dieser Angriff nutzt einen Zeiger auf eine Adresse, worin sich ein weiterer Zeiger auf die eigentlichen Daten befindet. Der sichere Prozess muss die Adresse zwischenspeichern, während der Pointer überprüft wird. Wird dies nicht durchgeführt, kann ein kompromittiertes Programm die Adresse des inneren Zeigers ändern, da sich der Speicherbereich außerhalb der Enklave befindet.