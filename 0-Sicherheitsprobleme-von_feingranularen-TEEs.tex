Wird die Sicherheit der Daten betrachtet, offenbart sich ein signifikanter Unterschied zwischen Trusted Execution Environments (TEE) mit einem gemeinsamen Adressraum und solchen mit einem separaten. Bei streng separierten Enklaven gestaltet es sich äußerst schwierig für unsichere Prozesse, die TEE zur Freigabe von Daten aus ihrem Speicher zu bewegen. Die Konfiguration des Trusted Operating Systems (TOS) kann entweder eine Spiegelung eines Teils des Adressraums oder den Zugriff auf externe Daten für den Datenaustausch in/von der Enklave ermöglichen. In beiden Fällen ist jedoch ein direkter Zugriff des Programms auf den Speicher der Anwendung nicht mehr gegeben.

Die Klassifizierung der Angriffsvektoren von Jo Van Bulck et al. erfolgt in zwei Hauptkategorien: Datenlecks und Datenkorruption. Diese Einteilung dient dazu, die Ziele der Angriffe zu charakterisieren und die potenziellen Auswirkungen auf die Sicherheit und Integrität der Daten zu bewerten.

\subsection{Datenlecks}
Unter Datenlecks versteht man Schwachstellen in denen ein Angreifer Informationen über das Layout, den Inhalt oder die Nutzung des Speichers der TEE gewinnen kann. Auch wenn es nicht möglich ist, die Daten der Enklave direkt zu lesen, kann die TEE durch externe Einflüsse dazu beinflusst werden, sich anders zu verhalten und so ungewollt Informationen preiszugeben. Das beginnt bei der Freigabe der letzten aufgerufenen Adresse, über die Anzahl der Aufrufe oder einzelnen Daten bis hin zum kompletten Speicherlayout der Enklave. 

Durch den 2. Angriffsvektor ist es möglich den Callstack auszulesen. Bei dem Angriffsvektor handelt es sich um die sichere Speicherung und anschließende Bereinigung des Callstacks beim Erstellen und Verlassen einer TEE. Wird dies nicht ordnungsgemäß durchgeführt, kann der Angreifer z.B. lesen, welche Funktionen aufgerufen wurden und so Rückschlüsse über die Funktionsreihenfolge, Art der Funktion und Zusammenhang zwischen den Funktionen erlangen. 

Eine weitere Schwachstelle bei dem Erstellen und Verlassen einer TEE betrifft andere Speicherzustände, wie die Registern. Nach dem 3. Angriffsvektor ist es für Angreifer möglich, nach dem Verlassen der TEE die Registerzustände auszulesen, wenn diese nicht ordnungsgemäß bereinigt werden. Selbst wenn das Bereinigen der Registerzustände in normalen Prozesswechseln üblich ist und automatisch erfolgt, kann es in einigen TEE-Implementierungen manuell erfolgen, was es zur Softwareverantwortung macht. Darüber hinaus muss bedacht werden, dass alle Angriffe,  die auf die hinterlassenen Daten abzielen, auch zutreffen, wenn die TEE durch ein Interrupt gestoppt wird.

Die TEE muss sicherstellen, dass der Inputpointer komplett außerhalb der Enklave liegt. Dieser 7. Angriffsvektor ist nur bei TEEs möglich, welche sich einen Adressraum mit der unsicheren Welt teilen, da es sich sonst um unterschiedliche Adressräume handelt und die Daten nicht nebeneinander in dem Adressraum liegen. Bei einem solchen Angriff kann ein Angreifer versuchen, den Anfang des Zeigers auf eine Adresse kurz vor der Enklave zeigen zu lassen, jedoch befindet sich der Buffer dann zum Teil in der Enklave, da sich beide den Adressraum teilen. Deshalb muss die TEE immer überprüfen, ob die gesamten übertragenen Daten außerhalb der Enklave liegen, um Datenklau zu vermeiden.

Ein noch spezialisierter Angriff betrifft die Manipulation von Strings, wie im 5. Angriffsvektor beschrieben ist. Bei Verwendung einer Low-Level-Sprache wie C verhält sich ein String als Array aus Chars, wobei zusätzlich die Länge angegeben werden muss, was von Angreifern ausgenutzt werden kann. Durch absichtlich falsche Angaben zur Länge und das Weglassen der Nullterminierung kann ein Angreifer die Position jedes /0 im Speicher der Enklave identifizieren. Da die TEE den String weiterhin ausliest und vollen Zugriff auf ihren Speicher hat, geht sie fälschlicherweise davon aus, dass der String bis zum nächsten /0 reicht. Über die Zeit und Reaktion der TEE kann der Angreifer Daten aus der Enklave bekommen. Dieser Seitenkanalangriff kann aber noch weiter verfeinert werden. Überschreibt man die Variable, die definiert, wie ein String behandelt wird, kann dadurch jedes andre einzelne Byte aus dem Speicher gewonnen werden und Angreifer könnten ein volles Abbild der Daten der Enklave haben.

\subsection{Datenkorruption}
